Striver Recursion

printing subsequence/subset
void func(int ind, vector<int> &ds, int arr[], int n) {
	if (ind == n) {
	// print statement
	for (auto it: ds) cout << it << "  ";
	cout << endl;
	return;
	}
	ds.push_back(arr[ind]);
	func(ind + 1, ds, arr, n);
	ds.pop_back();
	func(ind + 1, ds, arr, n);
}



divisible by k
void func(int ind, vector<int> &ds, int arr[], int n, int sum) {
	if (ind == n) {
	// print statement
	if (!ds.empty() && sum % k == 0) {
		for (auto it: ds) {
			cout << it << "  ";
		}
		cout << endl;
		return;
		}
	}
	ds.push_back(arr[ind]);
	sum += arr[ind];

	// pick it
	func(ind + 1, ds, arr, n);
	ds.pop_back();
	sum -= arr[ind];

	// not pick
	func(ind + 1, ds, arr, n);
}


// count divisible by k

f(0, sum) {
	if (ind == n) {
	if (sum % k == 0) return 1;
	else return 0;
	}
	sum += arr[ind];
	l = f(1, sum);
	sum -= arr[ind];
	r = f(1, sum);
	return l + r; // finale answer will contain 1 extra for empty sequence
}

// count divisible by k with repeation allowed

int countF(int ind, int sum, int arr[], int n) {
	if (ind == n) {
	if (sum == 0) return 1;
	else return 0;
	}
	int left = 0;
	int right = 0;

	if (a[ind] <= sum) {
	sum -= a[ind];
	left = countF(ind, sum, arr, n);
	sum += a[ind];
	}

	right = countF(ind + 1, sum, arr, n);

	return left + right;
}

// Right and down is allowed and we have print paths from starting to ending points in 2D matrix for eg. DDR, DDD etc.

void findPaths(int i, int j, string a) {

	if (i >= n || j >= m) return;

	if (i == n - 1 && j == m - 1 ) {
	cout << a << endl;
	return;
	}

	s += 'D';
	findPaths(i+1, j, a);
	s.pop_back();

	s += 'R';
	findPaths(i, j+1, a);
	s.pop_back();
}

// Right, Left, up and down is allowed and we have print paths from starting to ending points in 2D matrix for eg. DDR, DDD etc.

void findPaths(int i, int j, string a, vector<vector<int>> &vis) {

	if (i >= n || j >= m || i < 0 || j < 0 || vis[i][j] == 1) return;

	if (i == n - 1 && j == m - 1) {
	cout << a << endl;
	return;
	}

	vis[i][j] = 1;

/*	s += 'D';
	findPaths(i+1, j, a, vis);
	s.pop_back();

	s += 'R';
	findPaths(i, j+1, a, vis);
	s.pop_back();
								// Can be shorted using loop ans 
	s += 'U';					// arrays define below
	findPaths(i-1, j, a, vis);
	s.pop_back();
	
	s += 'L';
	findPaths(i, j-1, a, vis);
	s.pop_back();
*/

	for (int x = 0; x < 4; x++) {
		s += s[x];
		findPaths(i + di[x], j + dj[x], a, vis);
		s.pop_back();
	}

	vis[i][j] = 0;
}

char dIn[] = {'D', 'R', 'U', 'L'}; // for lexiographically 
									// array must be {D, L, R, U}
int di[] = {1, 0, -1, 0};
int dj[] = {0, 1, 0, -1};

// count no. of paths posible to final position from given 
// point in a 2D matirx "a" filled with 0s' and 1s'.
// 1 where path is possible.

int findPaths(int i, int j, int sum, vector<vector<int>> &vis) {

	if (i >= n || j >= m || i < 0 || j < 0 || vis[i][j] == 1 
		|| a[i][j] == 0) return 0;

	if (i == n - 1 && j == m - 1) return 1;

	vis[i][j] = 1;

	int count = 0;
	for (int x = 0; x < 4; x++) {
		count += findPaths(i + di[x], j + dj[x], a, vis);
	}

	vis[i][j] = 0;

	return count;
}

// print sub-sequence in array whose is divisible by k

bool func(int ind, vector<int> &ds, int sum) {
	if (ind == n) {
		if (sum % k == 0) {
			for (auto ele: ds) cout << ele << "  ";
			return true;
		}
		return false;
	}

	ds.push_back(arr[ind]);
	sum += arr[ind];

	if (func(ind+1, ds, sum) == true) return true;

	ds.pop_back();
	sum -= arr[ind];

	if (func(ind+1, ds, sum) == true) return true;
}

// N-Queen problem

int n; // size of chess board
bool NQueen(int col, vector<vector<int>> &mat) {
	if (col == n) {
		for(int i = 0;i<n;i++)
			for(int j = 0;j<n;j++)
				cout << mat[i][j] << "  ";
		cout <<endl;
		return true;
	}

	for (int row = 0; row < n;row++) {
		if (isSafe(row, col, mat)) {
			mat[row][col] = 1;
			if (Nqueen(col+1, mat) == true) return true;
			mat[row][col] = 0;
		}
	}
	return false;
}

bool isSafe(int col, int row, vector<vector<int>> &mat) {
	// row-- col--
	for (int i = row, j = col; i >= 0 && j>= 0; i--,j--)
		if (mat[i][j] == 1) return false;

	for (int i = row, j = col; i >= 0 && j>= 0; i,j--)
		if (mat[i][j] == 1) return false;

	for (int i = row, j = col; i >= 0 && j>= 0; i++,j--)
		if (mat[i][j] == 1) return false;

	return true;
}

// optimazation of N Queen
// rowHash must be filled with zero of size n
// firstHash and thirdHash must be filled with zero of size(2*n - 1)
bool NQueen(int col, vector<vector<int>> &mat, vector<int> rowHash,
			vector<int> firstHash, vector<int> thirdHash) {
	if (col == n) {
		for(int i = 0;i<n;i++)
			for(int j = 0;j<n;j++)
				cout << mat[i][j] << "  ";
		cout <<endl;
		return true;
	}

	for (int row = 0; row < n;row++) {
		if (isSafe(row, col, mat)) {
			mat[row][col] = 1;
			rowHash[row] = 1;
			firstHash[(n-1) + (row-col)] = 1;
			thirdHash[row+col] = 1;
			if (Nqueen(col+1, mat) == true) return true;
			mat[row][col] = 0;
			rowHash[row] = 0;
			firstHash[(n-1) + (row-col)] = 0;
			thirdHash[row+col] = 0;
		}
	}
	return false;
}

bool isSafe(int col, int row, vector<vector<int>> &mat, 
			vector<int> &rowHash, vector<int> &firstHash, 
			vector<int> &thirdHash) {
	if (rowHash[row] == 1 || firstHash[(n-1) + (row-col)]) 
		return false;

	return true;
}