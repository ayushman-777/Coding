// In and given array every number is present twice except 
// one find that one

int XOR = 0;
for (int i = 0; i < n; i++) {
	XOR = XOR^arr[i];
}

// for swapping two numbers

a = 5, b = 7

1. a = a^b  a = 5^7
2. b = a^b  b = 5^7^7 = 5
3. a = a^b  c = 5^7^5 = 7

Note:- a^a = 0

// Given n, print the XOR of all nos between (1-n)

by observing the pattern

if (n%4==0) print(n);
if (n%4==1) print(1);
if (n%4==2) print(n+1);
if (n%4==3) print(0);


// given a range (l-r) print the XOR (l^l+1^l+2^........r-1^r)

XOR(r) ^ XOR(l-1)

// for even odd program

if (n&1==0) even
else odd

// check if ith bit of given number is set or not. Set means true if 1, false if 0

if ((1<<i)&n == 0) true;
else false;

// Set the ith bit

n|(1<<i)

// Clear the ith bit

n&(~(1<<i))

// Remove the last set bit

n & (n-1)

// Check if number is power or 2

n & (n-1) == 0

// Number of set bits in given number

while (n!=0) {
	if (n&1==1) {
		count++;
	}
	n = n>>1;
}
print(count);
or, 
while (n!=1) {
	n = n&(n-1);
	count++;
}
print(count);

// Non Repeating Numbers

vector<int> singleNumber(vector<int> nums) 
    {
        int XOR = 0;
        for (auto ele: nums) XOR = XOR^ele;
        // cout << XOR;
        vector<int> ans;
        int XOR1 = 0, XOR2 = 0;
        int cnt = 0;
        while (XOR) {
            if (XOR&1) {
                break;
            }
            cnt++;
            XOR = XOR>>1;
        }
        for (auto ele: nums) {
            if (ele&(1<<cnt)) {
                XOR1 = XOR1^ele;
            } else XOR2 = XOR2^ele;
        }
        if (XOR1<XOR2) {
        ans.push_back(XOR1);
        ans.push_back(XOR2);
        } else {
        ans.push_back(XOR2);
        ans.push_back(XOR1);
        }
        return ans;
    }
    
    // Given n integers, print the XOR of all subsets

Always zero

// Prints all subset of array

for (nums = 0 -> (1<<n)-1) { //(1<<n)=2^n
	ds = [];
	for (bit = 0 -> n-1)
		ds.add(a[bit]);
	}
for (auto ele: ds) print(ele);


void copySetBits(unsigned &x, unsigned y,
                 unsigned l, unsigned r)
{
    // l and r must be between 1 to 32
    if (l < 1 || r > 32)
        return ;
 
    // get the length of the mask
    int maskLength = (1ll<<(r-l+1)) - 1;
 
    // Shift the mask to the required position
    // "&" with y to get the set bits at between
    // l ad r in y
    int mask = ((maskLength)<<(l-1)) & y ;
    x = x | mask;
}
